//
//  AspenTestCase.swift
//  Aspen
//
//  Created by Matt Drance on 10/1/15.
//  Copyright Â© 2015 Second Gear. All rights reserved.
//

import XCTest
@testable import Aspen


// Thx Matt Neuberg
func delay(_ delay: Double, block: () -> Void)
{
	DispatchQueue.global(attributes: DispatchQueue.GlobalAttributes.qosBackground).after(when: DispatchTime.now() + Double(Int64(delay * Double(NSEC_PER_SEC))) / Double(NSEC_PER_SEC), block: block)
}

class AspenTestCase: XCTestCase {

	var logNotifier: LogNotifier?
	var noLogObserver: NSObjectProtocol?

    override func tearDown() {
		self.removeNoLogObserver()
        super.tearDown()
    }

	// MARK: - Standard log setup

	/** 
		Installs a FileLogger, ConsoleLogger, and LogNotifier.
		LogNotifier enables the expectLog() and expectNoLog() assertions for testing.
	 */
	func registerLoggers()
	{
		// Don't register more loggers every time
		// Aspen.unregisterLogger() would be nice
		if (logNotifier == nil)
		{
			logNotifier = LogNotifier()
			Aspen.registerLogger(logNotifier!)
			Aspen.registerLogger(FileLogger())
			Aspen.registerLogger(ConsoleLogger())
		}
	}

	// MARK: - Log output confirmation

	func expectLog(_ timeout: Double = 0.5, test: (() -> Void)!)
	{
		precondition(logNotifier != nil, "Expected a LogNotifier to be installed before calling expectLog()")

		let _ = self.expectation(forNotification: AspenDidLogNotification, object: logNotifier!, handler: nil)
		test()
		self.waitForExpectations(withTimeout: timeout) { error in
			XCTAssertNil(error, "Expected log to fire. Set a breakpoint here to see which test failed")
		}
	}

	// MARK: - Log silence confirmation

	// This method exists to confirm that the log message enclosed in the test closure does not actually get logged.
	// An unfortunate amount of work needs to be done to accomplish this; see comments below
	func expectNoLog(_ test: (() -> Void)!)
	{
		precondition(logNotifier != nil, "Expected a LogNotifier to be installed before calling expectLog()")

		// First, add an observer for our LogNotifier that fails if a log notification is fired. (Remember, we expect no logging.)
		// That's the easy part. See comments inside addNoLogObserver() for the hard part.
		self.addNoLogObserver()

		// Because we expect a log to _not_ happen, we set up a basic timeout which signals success
		let expectation = self.expectation(withDescription: "Expected disqualified log to time out")
		delay(0.5) {
			// Remove the observer ASAP, to mitigate the race-y issues addressed by addNoLogObserver()
			self.removeNoLogObserver()
			// Fulfill the expectation. Assuming the notification observer above hasn't forced failure, there was no log message and the test passed.
			expectation.fulfill()
		}

		// Run the test closure. This is usually e.g. aspenVerbose("foo")
		test()

		// This should never time out; it should either pass, or fail via overt XCTFail in the notification observer
		self.waitForExpectations(withTimeout: 1.0) { error in
			XCTAssertNil(error, "Unreachable: Should have timed out waiting for log to not happen but got \(error)")
		}
	}

	func addNoLogObserver()
	{
		// Due to the asynchronous nature of Aspen and XCTestCase, it is possible during rapid run of expectNoLog()-based tests to get a false positive:
		// a latent notification that is not actually pertinent to the test at hand.
		// This method mitigates these conditions as well as possible.

		// First, confirm there is not a registered observer already; that would mean something is amiss from a previous test
		precondition(noLogObserver == nil)
		precondition(logNotifier != nil, "Expected a LogNotifier to be installed before calling addNoLogObserver()")

		let queue = OperationQueue()
		var observer: NSObjectProtocol? = nil
		observer = NotificationCenter.default.addObserver(forName: NSNotification.Name(rawValue: AspenDidLogNotification), object: logNotifier!, queue: queue) { [weak self] notification in
			// Avoid false positives by confirming that the assumed current observer is the observer that was actually tripped here
			// That way we don't fail one test for receiving another test's late notification
			if let obs1 = observer where obs1.isEqual(self?.noLogObserver)
			{
				XCTFail("Did not expect a log message during this test; got \((notification as NSNotification).userInfo?[AspenNotificationKeyMessage])")
			}
			else
			{
				print("Received an out-of-band \(notification.name) while expecting no activity; continuing, but something may be awry with this test's state / queue management: \(notification)")
			}
		}
		noLogObserver = observer
	}

	func removeNoLogObserver()
	{
		if let observer = noLogObserver
		{
			NotificationCenter.default.removeObserver(observer)
			noLogObserver = nil
		}
	}
}

let AspenDidLogNotification = "AspenDidLogNotification"
let AspenNotificationKeyMessage = "AspenMessage"

class LogNotifier: NSObject, LogInterface {

	func log(_ message: String)
	{
		NotificationCenter.default.post(name: Notification.Name(rawValue: AspenDidLogNotification), object: self, userInfo: [AspenNotificationKeyMessage: message])
	}
}
