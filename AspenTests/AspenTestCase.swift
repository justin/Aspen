//
//  AspenTestCase.swift
//  Aspen
//
//  Created by Matt Drance on 10/1/15.
//  Copyright Â© 2015 Second Gear. All rights reserved.
//

import XCTest
@testable import Aspen


// Thx Matt Neuberg
func delay(delay: Double, block: () -> Void)
{
	dispatch_after(dispatch_time(DISPATCH_TIME_NOW, Int64(delay * Double(NSEC_PER_SEC))), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), block)
}

@objc
class AspenTestCase: XCTestCase {

	var logNotifier: LogNotifier?
	var noLogObserver: NSObjectProtocol?

    override func setUp() {
        super.setUp()

		// Don't register more loggers every time a test is invoked
		// Aspen.unregisterLogger() would be nice
		if (logNotifier == nil)
		{
			logNotifier = LogNotifier()
			Aspen.registerLogger(logNotifier!)
			Aspen.registerLogger(FileLogger())
			Aspen.registerLogger(ConsoleLogger())
		}
    }
    
    override func tearDown() {
		self.removeNoLogObserver()
        super.tearDown()
    }

	// MARK: - Log output confirmation

	func expectLog(timeout: Double = 0.5, test: (() -> Void)!)
	{
		let _ = self.expectationForNotification(AspenDidLogNotification, object: nil, handler: nil)
		test()
		self.waitForExpectationsWithTimeout(timeout) { error in
			XCTAssertNil(error, "Expected log to fire. Set a breakpoint here to see which test failed")
		}
	}

	// MARK: - Log silence confirmation

	// This method exists to confirm that the log message enclosed in the test closure does not actually get logged.
	// An unfortunate amount of work needs to be done to accomplish this; see comments below
	func expectNoLog(test: (() -> Void)!)
	{
		// First, add an observer for our LogNotifier that fails if a log notification is fired. (Remember, we expect no logging.)
		// That's the easy part. See comments inside addNoLogObserver() for the hard part.
		self.addNoLogObserver()

		// Because we expect a log to _not_ happen, we set up a basic timeout which signals success
		let expectation = self.expectationWithDescription("Expected disqualified log to time out")
		delay(0.5) {
			// Remove the observer ASAP, to mitigate the race-y issues addressed by addNoLogObserver()
			self.removeNoLogObserver()
			// Fulfill the expectation. Assuming the notification observer above hasn't forced failure, there was no log message and the test passed.
			expectation.fulfill()
		}

		// Run the test closure. This is usually e.g. aspenVerbose("foo")
		test()

		// This should never time out; it should either pass, or fail via overt XCTFail in the notification observer
		self.waitForExpectationsWithTimeout(1.0) { error in
			XCTAssertNil(error, "Unreachable: Should have timed out waiting for log to not happen but got \(error)")
		}
	}

	func addNoLogObserver()
	{
		// Due to the asynchronous nature of Aspen and XCTestCase, it is possible during rapid run of expectNoLog()-based tests to get a false positive:
		// a latent notification that is not actually pertinent to the test at hand.
		// This method mitigates these conditions as well as possible.

		// First, confirm there is not a registered observer already; that would mean something is amiss from a previous test
		precondition(noLogObserver == nil)

		let queue = NSOperationQueue()
		var observer: NSObjectProtocol? = nil
		observer = NSNotificationCenter.defaultCenter().addObserverForName(AspenDidLogNotification, object: logNotifier!, queue: queue) { [weak self] notification in
			// Avoid false positives by confirming that the assumed current observer is the observer that was actually tripped here
			// That way we don't fail one test for receiving another test's late notification
			if let obs1 = observer where obs1.isEqual(self?.noLogObserver)
			{
				XCTFail("Did not expect a log message during this test; got \(notification.userInfo?[AspenNotificationKeyMessage])")
			}
			else
			{
				print("Received an out-of-band \(notification.name) while expecting no activity; continuing, but something may be awry with this test's state / queue management: \(notification)")
			}
		}
		noLogObserver = observer
	}

	func removeNoLogObserver()
	{
		if let observer = noLogObserver
		{
			NSNotificationCenter.defaultCenter().removeObserver(observer)
			noLogObserver = nil
		}
	}
}

let AspenDidLogNotification = "AspenDidLogNotification"
let AspenNotificationKeyMessage = "AspenMessage"

@objc
class LogNotifier: NSObject, LogInterface {

	func log(message: String)
	{
		NSNotificationCenter.defaultCenter().postNotificationName(AspenDidLogNotification, object: self, userInfo: [AspenNotificationKeyMessage: message])
	}
}
